<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>algorithm&amp;summary</title>
      <link href="/2020/03/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h4 id="快速处理区间加减问题-前缀和、二维前缀和与差分"><a href="#快速处理区间加减问题-前缀和、二维前缀和与差分" class="headerlink" title="快速处理区间加减问题-前缀和、二维前缀和与差分"></a>快速处理区间加减问题-前缀和、二维前缀和与差分</h4><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>在了解二维前缀和之前，我们首先需要了解一下什么是前缀和。</p><p>如果我给你一串长度为n的数列a1,a2,a3……an,再给出m个询问，每次询问给出L，R两个数，要求给出区间[L,R]里的数的和，你会怎么做，若是没有了解过前缀和的人看到这道题的想法可能是对于m次询问，我每次都遍历一遍它给的区间，计算出答案，这样子的方法固然没错，但是其时间复杂度达到了O(n*m)，如果数据量稍微大一点就有可能超时，而我们如果使用前缀和的方法来做的话就能够将时间复杂度降到O(n+m),大大节省了运算时间。至于怎么用，请看下面一小段代码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a[0]&#x3D;0;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)a[i]+&#x3D;a[i-1];</span><br></pre></td></tr></table></figure><p>没错，前缀和顾名思义就是前面i个数的总和。数组a在经过这样的操作之后，对于每次的询问，我们只需要计算a[R]-a[L-1]就能得到我们想要的答案了，是不是很简单呢。</p><p>在知道了最简单的前缀和之后，我们再来了解一下什么是差分。</p><p>给你一串长度为n的数列a1,a2,a3……an，要求对a[L]~a[R]进行m次操作：</p><p>操作一：将a[L]~a[R]内的元素都加上P</p><p>操作二：将a[L]~a[R]内的元素都减去P</p><p>最后再给出一个询问求a[L]-a[R]内的元素之和？</p><p>你会怎么做呢？你可能会想，我对于m次操作每次都遍历一遍a[L]~a[R],给区间里的数都加上P或减去P，最后再求一次前缀和就行了。没错，这样子确实也能得出正确答案，但时间复杂度却高达O(M*n)，对于1&lt;=n,m&lt;=1e5这个数据范围来说直接就tle了，所以说这个方法不可行。既然这样不行的话，那我们要怎么做才能快速的得到正确答案呢？是的，这个时候我们的差分就该派上用场了，我们新开一个数组b，储存每一次的修改操作，最后求前缀和的时候统计一下就能快速的得到正确答案了，详细请看下面代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int maxn &#x3D; 1e5+9;</span><br><span class="line">int[] a &#x3D; new int[maxn],b &#x3D; new int[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line"> int i,j,k,n,m,p;</span><br><span class="line">    Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">    n &#x3D; sc.nextInt();</span><br><span class="line">    m &#x3D; sc.nextInt();</span><br><span class="line">for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        a[i] &#x3D; sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">for(i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">int L,R,t;</span><br><span class="line">t &#x3D; sc.nextInt();</span><br><span class="line">        L &#x3D; sc.nextInt();</span><br><span class="line">        R &#x3D; sc.nextInt();</span><br><span class="line">        p &#x3D; sc.nextInt();</span><br><span class="line">if(t&#x3D;&#x3D;1)&#123;</span><br><span class="line">b[L]+&#x3D;p;b[R+1]-&#x3D;p; &#x2F;&#x2F;仔细想想为什么b[R+1]要减去p </span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">b[L]-&#x3D;p;b[R+1]+&#x3D;p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int add&#x3D;0;</span><br><span class="line">for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">add+&#x3D;b[i];</span><br><span class="line">a[i]+&#x3D;a[i-1]+add;</span><br><span class="line">&#125;</span><br><span class="line">int x,y;</span><br><span class="line">System.out.println(x);</span><br><span class="line">    System.out.println(y);</span><br><span class="line">    System.out.println(a[y]-a[x-1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信看到这里，大家已经仔细思考过代码了，为什么操作一时b[R+1]要减去p，很简单，因为操作一我只需对[L,R]区间里的数加p，[R+1,n]这个区间里的数没必要加p，所以需要减掉p。</p><p>差分讲解完毕，接下来我们终于要开始今天的正题——二维前缀和了。</p><h5 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h5><p>还是以小问题的形式来讲解二维前缀和吧。</p><p>给定一个n*m大小的矩阵a，有q次询问，每次询问给定x1,y1,x2,y2四个数，求以(x1,y1)为左上角坐标和(x2,y2)为右下角坐标的子矩阵的所有元素和。注意仍然包含左上角和右下角的元素。</p><p>怎么做呢？为了方便你们理解，我画个图吧。<br><img src="https://img-blog.csdn.net/20180817151423333?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfUl9mb3JldmVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>图画的很丑，希望不要介意。如图所示，按题目要求，我们每次要求的答案就是红色圆圈所在的区域的值（注意，这里的x1,x2表示行，y1,y2表示列),对比上面这张图我们能够发现红色区域的值等于四个区域的值减去（白色区域+黑色区域），再减去（白色区域+蓝色区域)，最后因为白色区域被减了两次，我们需要再加回来。所以ans=a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]；(注意，此时的a数组代表的是前缀和)。突然想起来还没说怎么求二维前缀和，很简单，看下面代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">for(int j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">a[i][j]+&#x3D;a[i][j-1]+a[i-1][j]-a[i-1][j-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为方便理解贴个图<br><img src="https://img-blog.csdn.net/20180817161822690?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfUl9mb3JldmVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>假如我想求a[2][4]的前缀和，我得先加上a[1][4]的前缀和，再加上a[2][3]的前缀和，然后这个时候我们发现实际上a[1][3]这个部分我们加了两遍，所以我们需要再减去一遍a[1][3]，于是得出公式a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1]。</p><p>接下来看完整代码吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn&#x3D;1e3+9;</span><br><span class="line">int a[maxn][maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">int i,j,k,n,m,q;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">for(j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">for(j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">a[i][j]+&#x3D;a[i][j-1]+a[i-1][j]-a[i-1][j-1];</span><br><span class="line">&#125;</span><br><span class="line">for(i&#x3D;1;i&lt;&#x3D;q;i++)&#123;</span><br><span class="line">int x1,y1,x2,y2;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">int ans&#x3D;a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1];</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉很简单呢，哈哈哈哈哈哈哈。</p><p>在学完二维前缀和之后，一些同学可能会有疑问，一维前缀和能用上差分，那么二维前缀和能不能用上差分呢？答案是肯定的。</p><h5 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h5><p>那么怎么差分呢？方法是和一维类似的，我们也是需要另开一个数组记录修改操作，最后求前缀和时统计修改操作，只是二维每一次操作需要记录4个位置，一维只需要记录2个位置。具体怎么做，看下面代码吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;m;i++)&#123;&#x2F;&#x2F;m是修改操作次数 </span><br><span class="line">int x1,y1,x2,y2,p;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;p;</span><br><span class="line">b[x1][y1]+&#x3D;p;b[x2+1][y2+1]+&#x3D;p;</span><br><span class="line">b[x2+1][y1]-&#x3D;p;b[x1][y2+1]-&#x3D;p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，一维前缀和、二维前缀和、差分都说完了，希望看这篇文章的人能够有所收获吧。</p><p>@<a href="https://blog.csdn.net/K_R_forever/article/details/81775899?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">原文链接</a></p><h4 id="二分查找细节分析"><a href="#二分查找细节分析" class="headerlink" title="二分查找细节分析"></a>二分查找细节分析</h4><blockquote><p>思路</p></blockquote><p>我相信对很多读者朋友来说，编写二分查找的算法代码属于玄学编程，虽然看起来很简单，就是会出错，要么会漏个等号，要么少加个 1。</p><p>不要气馁，因为二分查找其实并不简单。看看 Knuth 大佬（发明 KMP 算法的那位）怎么说的：</p><blockquote><p>Although the basic idea of binary search is comparatively straightforward,<br>the details can be surprisingly tricky…</p></blockquote><p>这句话可以这样理解：思路很简单，细节是魔鬼。很多人喜欢拿整型溢出的 bug 说事儿，但是二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 mid 加一还是减一，while 里到底用 &lt;= 还是 &lt;</p><p>你要是没有正确理解这些细节，写二分肯定就是玄学编程，有没有 bug 只能靠菩萨保佑。我特意写了一首诗来歌颂该算法，概括本文的主要内容，建议保存：<br><img src="https://pic.leetcode-cn.com/c53e309f6591906bb643ccb2a1ace7bcff7f1eb3d788ec72979ea717f66baf71.png" alt=""></p><p>本文以问答的形式，探究几个最常用的二分查找场景：寻找一个数. 寻找左侧边界. 寻找右侧边界。第一个场景是最简单的算法形式，解决 这道题，后两个场景就是本题。</p><p>本文就来探究几个最常用的二分查找场景：寻找一个数. 寻找左侧边界. 寻找右侧边界。而且，我们就是要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。</p><h5 id="零-二分查找框架"><a href="#零-二分查找框架" class="headerlink" title="零-二分查找框架"></a>零-二分查找框架</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; ...;</span><br><span class="line"></span><br><span class="line">    while(...) &#123;</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left &#x3D; ...</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right &#x3D; ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。</p><p>其中 … 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p><p>另外声明一下，计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。</p><h5 id="一-寻找一个数（基本的二分搜索）"><a href="#一-寻找一个数（基本的二分搜索）" class="headerlink" title="一-寻找一个数（基本的二分搜索）"></a>一-寻找一个数（基本的二分搜索）</h5><p>这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0;</span><br><span class="line">    int right &#x3D; nums.length - 1; &#x2F;&#x2F; 注意</span><br><span class="line"></span><br><span class="line">    while(left &lt;&#x3D; right) &#123;</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        if(nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">            return mid;</span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left &#x3D; mid + 1; &#x2F;&#x2F; 注意</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right &#x3D; mid - 1; &#x2F;&#x2F; 注意</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为什么 while 循环的条件中是 &lt;=，而不是 &lt;？</li></ol><p>答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。<br>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。<br>我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间。<br>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(nums[mid] &#x3D;&#x3D; target) return mid;</span><br></pre></td></tr></table></figure><p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。<br>while(left &lt;= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。<br>while(left &lt; right) 的终止条件是 left == right，写成区间的形式就是 [left, right]，或者带个具体的数字进去 [2, 2]，这时候区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。<br>当然，如果你非要用 while(left &lt; right) 也可以，我们已经知道了出错的原因，就打个补丁好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;...</span><br><span class="line">while(left &lt; right) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">return nums[left] &#x3D;&#x3D; target ? left : -1;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？<br>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。<br>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，下一步应该去搜索哪里呢？<br>当然是去搜索 [left, mid-1] 或者 [mid+1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。</p></li><li><p>此算法有什么缺陷？<br>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。<br>比如说给你有序数组 nums = [1,2,2,2,3]，target 为 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。<br>这样的需求很常见，你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。<br>我们后续的算法就来讨论这两种二分查找的算法。</p></li></ol><h5 id="二-寻找左侧边界的二分搜索"><a href="#二-寻找左侧边界的二分搜索" class="headerlink" title="二-寻找左侧边界的二分搜索"></a>二-寻找左侧边界的二分搜索</h5><p>以下是最常见的代码形式，其中的标记是需要注意的细节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">    if (nums.length &#x3D;&#x3D; 0) return -1;</span><br><span class="line">    int left &#x3D; 0;</span><br><span class="line">    int right &#x3D; nums.length; &#x2F;&#x2F; 注意</span><br><span class="line"></span><br><span class="line">    while (left &lt; right) &#123; &#x2F;&#x2F; 注意</span><br><span class="line">        int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            right &#x3D; mid;</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right &#x3D; mid; &#x2F;&#x2F; 注意</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>为什么 while 中是 &lt; 而不是 &lt;=?<br>答：用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right) 左闭右开。<br>while(left &lt; right) 终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以可以正确终止。<br>PS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：刚才的 right 不是 nums.length - 1 吗，为啥这里非要写成 nums.length 使得「搜索区间」变成左闭右开呢？<br>因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。</p></li><li><p>为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？<br><img src="https://pic.leetcode-cn.com/761f2acd823c960125e3dddb56f2d811da9c39455fe3f2ee00d3998048a1d6c9.jpg" alt=""></p></li></ol><p>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：<br>对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 2 的元素有 1 个。<br>比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1 的元素有 0 个。<br>再比如说 nums = [2,3,5,7], target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个。<br>综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，所以我们简单添加两行代码就能在正确的时候 return -1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (left &lt; right) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; target 比所有数都大</span><br><span class="line">if (left &#x3D;&#x3D; nums.length) return -1;</span><br><span class="line">&#x2F;&#x2F; 类似之前算法的处理方式</span><br><span class="line">return nums[left] &#x3D;&#x3D; target ? left : -1;</span><br></pre></td></tr></table></figure><ol start="3"><li>为什么 left = mid + 1，right = mid ？和之前的算法不一样？<br>答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。</li><li>为什么该算法能够搜索左侧边界？<br>答：关键在于对于 nums[mid] == target 这种情况的处理：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">    right &#x3D; mid;</span><br></pre></td></tr></table></figure><p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p><ol start="5"><li><p>为什么返回 left 而不是 right？<br>答：都是一样的，因为 while 终止的条件是 left == right。</p></li><li><p>能不能想办法把 right 变成 nums.length - 1，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了。<br>答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：<br>因为你非要让搜索区间两端都闭，所以 right 应该初始化为 nums.length - 1，while 的终止条件应该是 left == right + 1，也就是其中应该用 &lt;=：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">    &#x2F;&#x2F; 搜索区间为 [left, right]</span><br><span class="line">    int left &#x3D; 0, right &#x3D; nums.length - 1;</span><br><span class="line">    while (left &lt;&#x3D; right) &#123;</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; if else ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 left 和 right 的更新逻辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (nums[mid] &lt; target) &#123;</span><br><span class="line">    &#x2F;&#x2F; 搜索区间变为 [mid+1, right]</span><br><span class="line">    left &#x3D; mid + 1;</span><br><span class="line">&#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">    &#x2F;&#x2F; 搜索区间变为 [left, mid-1]</span><br><span class="line">    right &#x3D; mid - 1;</span><br><span class="line">&#125; else if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">    &#x2F;&#x2F; 收缩右侧边界</span><br><span class="line">    right &#x3D; mid - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 while 的退出条件是 left == right + 1，所以当 target 比 nums 中所有元素都大时，会存在以下情况使得索引越界：<br><img src="https://pic.leetcode-cn.com/6922fcf9e7ce6faae8f2c60047cb7ebf49a561887e095b46d9ea60aa0e99945b.jpg" alt=""></p><p>因此，最后返回结果的代码应该检查越界情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (left &gt;&#x3D; nums.length || nums[left] !&#x3D; target)</span><br><span class="line">    return -1;</span><br><span class="line">return left;</span><br></pre></td></tr></table></figure><p>至此，整个算法就写完了，完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; nums.length - 1;</span><br><span class="line">    &#x2F;&#x2F; 搜索区间为 [left, right]</span><br><span class="line">    while (left &lt;&#x3D; right) &#123;</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &lt; target) &#123;</span><br><span class="line">            &#x2F;&#x2F; 搜索区间变为 [mid+1, right]</span><br><span class="line">            left &#x3D; mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            &#x2F;&#x2F; 搜索区间变为 [left, mid-1]</span><br><span class="line">            right &#x3D; mid - 1;</span><br><span class="line">        &#125; else if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            &#x2F;&#x2F; 收缩右侧边界</span><br><span class="line">            right &#x3D; mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 检查出界情况</span><br><span class="line">    if (left &gt;&#x3D; nums.length || nums[left] !&#x3D; target)</span><br><span class="line">        return -1;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 left 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。</p><h5 id="三-寻找右侧边界的二分查找"><a href="#三-寻找右侧边界的二分查找" class="headerlink" title="三-寻找右侧边界的二分查找"></a>三-寻找右侧边界的二分查找</h5><p>类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int right_bound(int[] nums, int target) &#123;</span><br><span class="line">    if (nums.length &#x3D;&#x3D; 0) return -1;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; nums.length;</span><br><span class="line">    </span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1; &#x2F;&#x2F; 注意</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right &#x3D; mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left - 1; &#x2F;&#x2F; 注意</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为什么这个算法能够找到右侧边界？<br>答：类似地，关键点还是这里：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">    left &#x3D; mid + 1;</span><br></pre></td></tr></table></figure><p>当 nums[mid] == target 时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。</p><ol start="2"><li>为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。<br>答：首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。<br>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">    left &#x3D; mid + 1;</span><br><span class="line">    &#x2F;&#x2F; 这样想: mid &#x3D; left - 1</span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/f6b0418e62a8413a383d32d1f9be4130a1a253c3728d7ff7155cf6b626b4a53d.jpg" alt=""></p><p>因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。<br>至于为什么 left 的更新必须是 left = mid + 1，同左侧边界搜索，就不再赘述。</p><ol start="3"><li>为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？<br>答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 [0, nums.length]，所以可以添加两行代码，正确地返回 -1：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (left &lt; right) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">if (left &#x3D;&#x3D; 0) return -1;</span><br><span class="line">return nums[left-1] &#x3D;&#x3D; target ? (left-1) : -1;</span><br></pre></td></tr></table></figure><ol start="4"><li>是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了。<br>答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int right_bound(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; nums.length - 1;</span><br><span class="line">    while (left &lt;&#x3D; right) &#123;</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right &#x3D; mid - 1;</span><br><span class="line">        &#125; else if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里改成收缩左侧边界即可</span><br><span class="line">            left &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 这里改为检查 right 越界的情况，见下图</span><br><span class="line">    if (right &lt; 0 || nums[right] !&#x3D; target)</span><br><span class="line">        return -1;</span><br><span class="line">    return right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 target 比所有元素都小时，right 会被减到 -1，所以需要在最后防止越界：<br><img src="https://pic.leetcode-cn.com/7a4f522758ba0a7d7934ec750d1c3121be163919a67924dbcdf0bbef8d63485a.jpg" alt=""></p><p>至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？</p><h5 id="四-逻辑统一"><a href="#四-逻辑统一" class="headerlink" title="四-逻辑统一"></a>四-逻辑统一</h5><p>来梳理一下这些细节差异的因果逻辑：</p><ul><li><p>第一个，最基本的二分查找算法：<br>因为我们初始化 right = nums.length - 1<br>所以决定了我们的「搜索区间」是 [left, right]<br>所以决定了 while (left &lt;= right)<br>同时也决定了 left = mid+1 和 right = mid-1<br>因为我们只需找到一个 target 的索引即可<br>所以当 nums[mid] == target 时可以立即返回</p></li><li><p>第二个，寻找左侧边界的二分查找：<br>因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 while (left &lt; right)<br>同时也决定了 left = mid + 1 和 right = mid<br>因为我们需找到 target 的最左侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧右侧边界以锁定左侧边界</p></li><li><p>第三个，寻找右侧边界的二分查找：<br>因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 while (left &lt; right)<br>同时也决定了 left = mid + 1 和 right = mid<br>因为我们需找到 target 的最右侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧左侧边界以锁定右侧边界<br>又因为收紧左侧边界时必须 left = mid + 1<br>所以最后无论返回 left 还是 right，必须减一<br>对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">int binary_search(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; nums.length - 1;</span><br><span class="line">    while(left &lt;&#x3D; right) &#123;</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right &#x3D; mid - 1;</span><br><span class="line">        &#125; else if(nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            &#x2F;&#x2F; 直接返回</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 直接返回</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; nums.length - 1;</span><br><span class="line">    while (left &lt;&#x3D; right) &#123;</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right &#x3D; mid - 1;</span><br><span class="line">        &#125; else if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            &#x2F;&#x2F; 别返回，收缩左侧边界</span><br><span class="line">            right &#x3D; mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 最后要检查 left 越界的情况</span><br><span class="line">    if (left &gt;&#x3D; nums.length || nums[left] !&#x3D; target)</span><br><span class="line">        return -1;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int right_bound(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; nums.length - 1;</span><br><span class="line">    while (left &lt;&#x3D; right) &#123;</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right &#x3D; mid - 1;</span><br><span class="line">        &#125; else if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            &#x2F;&#x2F; 别返回，收缩右侧边界</span><br><span class="line">            left &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 最后要检查 right 越界的情况</span><br><span class="line">    if (right &lt; 0 || nums[right] !&#x3D; target)</span><br><span class="line">        return -1;</span><br><span class="line">    return right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。</p><p>通过本文，你学会了：</p><ol><li>分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。</li><li>注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。</li><li>如需定义左闭右开的「搜索区间」搜索左右边界，只要在 nums[mid] == target 时做修改即可，搜索右侧时需要减一。</li><li>如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 nums[mid] == target 条件处的代码和返回的逻辑即可，推荐拿小本本记下，作为二分搜索模板。<br>最后，点击我的头像可以查看更多详细题解，希望读者多多点赞，让我感受到你的认可～</li><li>推荐阅读：<ul><li>回溯算法详解</li><li>KMP 算法详解</li><li>LRU 缓存淘汰算法详解</li><li>腾讯面试题详解：编辑距离</li></ul></li></ol><p>PS：我的所有算法文章都已经上传到了 Github 仓库：<a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener">fucking-algorithm</a>，共 60 多篇，绝对精品，肯定让你收获满满，求个 star 不过分吧～<br>PPS：我最近精心制作了一份电子书《labuladong的算法小抄》，分为「动态规划」「数据结构」「算法思维」「高频面试」四个章节，目录如下，如有需要可扫码到我的公众号 labuladong 后台回复关键词「pdf」下载：</p><blockquote><p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> lc&amp;nc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java AOP分析</title>
      <link href="/2020/03/09/Java-AOP%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/09/Java-AOP%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><ul><li><p>其实, 接触了这么久的 AOP, 我感觉, AOP 给人难以理解的一个关键点是它的概念比较多, 而且坑爹的是, 这些概念经过了中文翻译后, 变得面目全非, 相同的一个术语, 在不同的翻译下, 含义总有着各种莫名其妙的差别. 鉴于此, 我在本章的开头, 着重为为大家介绍一个 Spring AOP 的各项术语的基本含义. 为了术语传达的准确性, 我在接下来的叙述中, 能使用英文术语的地方, 尽量使用英文.</p></li><li><p>什么是 AOP<br>AOP(Aspect-Oriented Programming), 即 面向切面编程 , 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)</p><a id="more"></a></li><li><p>术语<br>Aspect(切面)<br>aspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中.AOP的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作:</p></li></ul><p>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上<br>如何在 advice 中编写切面代码.<br>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p><p>advice(增强)<br>由 aspect 添加到特定的 join point(即满足 point cut 规则的 join point) 的一段代码.许多 AOP框架, 包括 Spring AOP, 会将 advice 模拟为一个拦截器(interceptor), 并且在 join point 上维护多个 advice, 进行层层拦截.例如 HTTP 鉴权的实现, 我们可以为每个使用 RequestMapping 标注的方法织入 advice, 当 HTTP 请求到来时, 首先进入到 advice 代码中, 在这里我们可以分析这个 HTTP 请求是否有相应的权限, 如果有, 则执行 Controller, 如果没有, 则抛出异常. 这里的 advice 就扮演着鉴权拦截器的角色了.</p><p>连接点(join point)<br>a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</p><p>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.在 Spring AOP 中, join point 总是方法的执行点, 即只有方法连接点.</p><p>切点(point cut)<br>匹配 join point 的谓词(a predicate that matches join points).Advice 是和特定的 point cut 关联的, 并且在 point cut 相匹配的 join point 中执行.在 Spring 中, 所有的方法都可以认为是 joinpoint, 但是我们并不希望在所有的方法上都添加 Advice, 而 pointcut 的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice.</p><p>关于join point 和 point cut 的区别<br>在 Spring AOP 中, 所有的方法执行都是 join point. 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西.advice 是在 join point 上执行的, 而 point cut 规定了哪些 join point 可以执行哪些 advice</p><p>introduction<br>为一个类型添加额外的方法或字段. Spring AOP 允许我们为 目标对象 引入新的接口(和对应的实现). 例如我们可以使用 introduction 来为一个 bean 实现 IsModified 接口, 并以此来简化 caching 的实现.</p><p>目标对象(Target)<br>织入 advice 的目标对象. 目标对象也被称为 advised object.因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类.</p><p>AOP proxy<br>一个类被 AOP 织入 advice, 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类.在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象.</p><p>织入(Weaving)<br>将 aspect 和其他对象连接起来, 并创建 adviced object 的过程.根据不同的实现技术, AOP织入有三种方式:</p><p>编译器织入, 这要求有特殊的Java编译器.<br>类装载期织入, 这需要有特殊的类装载器.<br>动态代理织入, 在运行期为目标类添加增强(Advice)生成子类的方式.Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期织入.</p><ul><li>advice 的类型<br>before advice, 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)<br>after return advice, 在一个 join point 正常返回后执行的 advice<br>after throwing advice, 当一个 join point 抛出异常后执行的 advice<br>after(final) advice, 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice.<br>around advice, 在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice.</li><li>关于 AOP Proxy<br>Spring AOP 默认使用标准的 JDK 动态代理(dynamic proxy)技术来实现 AOP 代理, 通过它, 我们可以为任意的接口实现代理.如果需要为一个类实现代理, 那么可以使用 CGLIB 代理. 当一个业务逻辑对象没有实现接口时, 那么Spring AOP 就默认使用 CGLIB 来作为 AOP 代理了. 即如果我们需要为一个方法织入 advice, 但是这个方法不是一个接口所提供的方法, 则此时 Spring AOP 会使用 CGLIB 来实现动态代理. 鉴于此, Spring AOP 建议基于接口编程, 对接口进行 AOP 而不是类.</li></ul><h4 id="彻底理解-aspect-join-point-point-cut-advice"><a href="#彻底理解-aspect-join-point-point-cut-advice" class="headerlink" title="彻底理解 aspect, join point, point cut, advice"></a>彻底理解 aspect, join point, point cut, advice</h4><p>看完了上面的理论部分知识, 我相信还是会有不少朋友感觉到 AOP 的概念还是很模糊, 对 AOP 中的各种概念理解的还不是很透彻. 其实这很正常, 因为 AOP 中的概念是在是太多了, 我当时也是花了老大劲才梳理清楚的.下面我以一个简单的例子来比喻一下 AOP 中 aspect, jointpoint, pointcut 与 advice 之间的关系.</p><p>让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来.</p><p>来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系.首先我们知道, 在 Spring AOP 中 join point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, join point 就相当于 爪哇的小县城里的百姓 , point cut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸 , 而 advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问 .为什么可以这样类比呢?</p><p>join point –&gt; 爪哇的小县城里的百姓: 因为根据定义, join point 是所有可能被织入 advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 join point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.<br>point cut –&gt; 男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 advice, 但是我们并不希望在所有方法上都织入 advice, 而 pointcut 的作用就是提供一组规则来匹配joinpoint, 给满足规则的 joinpoint 添加 advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里 凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.<br>advice –&gt; 抓过来审问, advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 join point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓.<br>aspect: aspect 是 point cut 与 advice 的组合, 因此在这里我们就可以类比: “根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问” 这一整个动作可以被认为是一个 aspect.<br>或则我们也可以从语法的角度来简单类比一下. 我们在学英语时, 经常会接触什么 定语, 被动句 之类的概念, 那么可以做一个不严谨的类比, 即 joinpoint 可以认为是一个 宾语, 而 pointcut 则可以类比为修饰 joinpoint 的定语, 那么整个 aspect 就可以描述为: 满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作.</p><blockquote><p>@AspectJ 支持<br>@AspectJ 是一种使用 Java 注解来实现 AOP 的编码风格.@AspectJ 风格的 AOP 是 AspectJ Project 在 AspectJ 5 中引入的, 并且 Spring 也支持@AspectJ 的 AOP 风格.</p></blockquote><ul><li>使能 @AspectJ 支持<br>@AspectJ 可以以 XML 的方式或以注解的方式来使能, 并且不论以哪种方式使能@ASpectJ, 我们都必须保证 aspectjweaver.jar 在 classpath 中.</li><li>使用 Java Configuration 方式使能@AspectJ</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">publicclass AppConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义 aspect(切面)<br>当使用注解 @Aspect 标注一个 Bean 后, 那么 Spring 框架会自动收集这些 Bean, 并添加到 Spring AOP 中, 例如:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">publicclass MyTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意, 仅仅使用@Aspect 注解, 并不能将一个 Java 对象转换为 Bean, 因此我们还需要使用类似 @Component 之类的注解.注意, 如果一个 类被@Aspect 标注, 则这个类就不能是其他 aspect 的 advised object 了, 因为使用 @Aspect 后, 这个类就会被排除在 auto-proxying 机制之外.</p></blockquote><ul><li>声明 pointcut<br>一个 pointcut 的声明由两部分组成:</li></ul><p>一个方法签名, 包括方法名和相关参数<br>一个 pointcut 表达式, 用来指定哪些方法执行是我们感兴趣的(即因此可以织入 advice).<br>在@AspectJ 风格的 AOP 中, 我们使用一个方法来描述 pointcut, 即:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;execution(* com.xys.service.UserService.*(..))&quot;) &#x2F;&#x2F; 切点表达式</span><br><span class="line">private void dataAccessOperation() &#123;&#125; &#x2F;&#x2F; 切点前面</span><br></pre></td></tr></table></figure><p>这个方法必须无返回值.这个方法本身就是 pointcut signature, pointcut 表达式使用@Pointcut 注解指定.上面我们简单地定义了一个 pointcut, 这个 pointcut 所描述的是: 匹配所有在包 com.xys.service.UserService 下的所有方法的执行.</p><p>切点标志符(designator)<br>AspectJ5 的切点表达式由标志符(designator)和操作参数组成. 如 “execution( greetTo(..))” 的切点表达式, execution 就是 标志符, 而圆括号里的 greetTo(..) 就是操作参数</p><p>execution<br>匹配 join point 的执行, 例如 “execution(* hello(..))” 表示匹配所有目标类中的 hello() 方法. 这个是最基本的 pointcut 标志符.</p><p>within<br>匹配特定包下的所有 join point, 例如 within(com.xys.<em>) 表示 com.xys 包中的所有连接点, 即包中的所有类的所有方法. 而 within(com.xys.service.</em>Service) 表示在 com.xys.service 包中所有以 Service 结尾的类的所有的连接点.</p><p>this 与 target<br>this 的作用是匹配一个 bean, 这个 bean(Spring AOP proxy) 是一个给定类型的实例(instance of). 而 target 匹配的是一个目标对象(target object, 即需要织入 advice 的原始的类), 此对象是一个给定类型的实例(instance of).</p><p>bean<br>匹配 bean 名字为指定值的 bean 下的所有方法, 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bean(*Service) &#x2F;&#x2F; 匹配名字后缀为 Service 的 bean 下的所有方法</span><br><span class="line">bean(myService) &#x2F;&#x2F; 匹配名字为 myService 的 bean 下的所有方法</span><br></pre></td></tr></table></figure><ul><li>args<br>匹配参数满足要求的的方法.例如:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;within(com.xys.demo2.*)&quot;)</span><br><span class="line">public void pointcut2() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Before(value &#x3D; &quot;pointcut2()  &amp;&amp;  args(name)&quot;)</span><br><span class="line">public void doSomething(String name) &#123;</span><br><span class="line">    logger.info(&quot;---page: &#123;&#125;---&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line">@Service</span><br><span class="line">publicclass NormalService &#123;</span><br><span class="line">    private Logger logger &#x3D; LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    public void someMethod() &#123;</span><br><span class="line">        logger.info(&quot;---NormalService: someMethod invoked---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String test(String name) &#123;</span><br><span class="line">        logger.info(&quot;---NormalService: test invoked---&quot;);</span><br><span class="line">        return&quot;服务一切正常&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 NormalService.test 执行时, 则 advice doSomething 就会执行, test 方法的参数 name 就会传递到 doSomething 中.<br>常用例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 匹配只有一个参数 name 的方法</span><br><span class="line">@Before(value &#x3D; &quot;aspectMethod()  &amp;&amp;  args(name)&quot;)</span><br><span class="line">public void doSomething(String name) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配第一个参数为 name 的方法</span><br><span class="line">@Before(value &#x3D; &quot;aspectMethod()  &amp;&amp;  args(name, ..)&quot;)</span><br><span class="line">public void doSomething(String name) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配第二个参数为 name 的方法</span><br><span class="line">Before(value &#x3D; &quot;aspectMethod()  &amp;&amp;  args(*, name, ..)&quot;)</span><br><span class="line">public void doSomething(String name) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@annotation<br>匹配由指定注解所标注的方法, 例如:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Pointcut(&quot;@annotation(com.xys.demo1.AuthChecker)&quot;)</span><br><span class="line">public void pointcut() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则匹配由注解 AuthChecker 所标注的方法.</p><ul><li>常见的切点表达式<br>匹配方法签名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 匹配指定包中的所有的方法</span><br><span class="line">execution(* com.xys.service.*(..))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配当前包中的指定类的所有方法</span><br><span class="line">execution(* UserService.*(..))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配指定包中的所有 public 方法</span><br><span class="line">execution(public * com.xys.service.*(..))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配指定包中的所有 public 方法, 并且返回值是 int 类型的方法</span><br><span class="line">execution(publicint com.xys.service.*(..))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配指定包中的所有 public 方法, 并且第一个参数是 String, 返回值是 int 类型的方法</span><br><span class="line">execution(publicint com.xys.service.*(String name, ..))</span><br></pre></td></tr></table></figure><ul><li>匹配类型签名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 匹配指定包中的所有的方法, 但不包括子包</span><br><span class="line">within(com.xys.service.*)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配指定包中的所有的方法, 包括子包</span><br><span class="line">within(com.xys.service..*)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配当前包中的指定类中的方法</span><br><span class="line">within(UserService)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配一个接口的所有实现类中的实现的方法</span><br><span class="line">within(UserDao+)</span><br></pre></td></tr></table></figure><ul><li>匹配 Bean 名字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 匹配以指定名字结尾的 Bean 中的所有方法</span><br><span class="line">bean(*Service)</span><br></pre></td></tr></table></figure><ul><li>切点表达式组合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 匹配以 Service 或 ServiceImpl 结尾的 bean</span><br><span class="line">bean(*Service || *ServiceImpl)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配名字以 Service 结尾, 并且在包 com.xys.service 中的 bean</span><br><span class="line">bean(*Service) &amp;&amp; within(com.xys.service.*)</span><br></pre></td></tr></table></figure><ul><li>声明 advice<br>advice 是和一个 pointcut 表达式关联在一起的, 并且会在匹配的 join point 的方法执行的前/后/周围 运行. pointcut 表达式可以是简单的一个 pointcut 名字的引用, 或者是完整的 pointcut 表达式.下面我们以几个简单的 advice 为例子, 来看一下一个 advice 是如何声明的.</li></ul><p>Before advice</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author xiongyongshun</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @created 16&#x2F;9&#x2F;9 13:13</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">publicclass BeforeAspectTest &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.</span><br><span class="line">    @Pointcut(&quot;execution(* com.xys.service.UserService.*(..))&quot;)</span><br><span class="line">    public void dataAccessOperation() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">publicclass AdviseDefine &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义 advise</span><br><span class="line">    @Before(&quot;com.xys.aspect.PointcutDefine.dataAccessOperation()&quot;)</span><br><span class="line">    public void doBeforeAccessCheck(JoinPoint joinPoint) &#123;</span><br><span class="line">        System.out.println(&quot;*****Before advise, method: &quot; + joinPoint.getSignature().toShortString() + &quot; *****&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里, @Before 引用了一个 pointcut, 即 “com.xys.aspect.PointcutDefine.dataAccessOperation()” 是一个 pointcut 的名字.如果我们在 advice 在内置 pointcut, 则可以:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">publicclass AdviseDefine &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 pointcut 和 advice 同时定义</span><br><span class="line">    @Before(&quot;within(com.xys.service..*)&quot;)</span><br><span class="line">    public void doAccessCheck(JoinPoint joinPoint) &#123;</span><br><span class="line">        System.out.println(&quot;*****doAccessCheck, Before advise, method: &quot; + joinPoint.getSignature().toShortString() + &quot; *****&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>around advice<br>around advice 比较特别, 它可以在一个方法的之前之前和之后添加不同的操作, 并且甚至可以决定何时, 如何, 是否调用匹配到的方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">publicclass AdviseDefine &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义 advise</span><br><span class="line">    @Around(&quot;com.xys.aspect.PointcutDefine.dataAccessOperation()&quot;)</span><br><span class="line">    public Object doAroundAccessCheck(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">        StopWatch stopWatch &#x3D; new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        &#x2F;&#x2F; 开始</span><br><span class="line">        Object retVal &#x3D; pjp.proceed();</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        &#x2F;&#x2F; 结束</span><br><span class="line">        System.out.println(&quot;invoke method: &quot; + pjp.getSignature().getName() + &quot;, elapsed time: &quot; + stopWatch.getTotalTimeMillis());</span><br><span class="line">        return retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>around advice 和前面的 before advice 差不多, 只是我们把注解 @Before 改为了 @Around 了.</p>]]></content>
      
      
      <categories>
          
          <category> Java_enhance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lc经典题目分类总结</title>
      <link href="/2020/03/07/lc%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/07/lc%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lc&amp;nc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lc题目总结</title>
      <link href="/2020/03/01/lt%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/01/lt%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>easy205. 同构字符串</p></blockquote><ul><li>使用嵌套数组同样可以实现map映射<blockquote><p>mid179. 最大数</p></blockquote><a id="more"></a></li><li>fast<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public String largestNumber(int[] nums) &#123;</span><br><span class="line">        String[] numstr &#x3D; new String[nums.length];</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            numstr[i] &#x3D; String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(numstr,0,nums.length-1);</span><br><span class="line">        &#x2F;&#x2F; System.out.println(Arrays.toString(numstr));</span><br><span class="line">        StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">        if(numstr[0].charAt(0)&#x3D;&#x3D;&#39;0&#39;)&#123;</span><br><span class="line">            return &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(String num:numstr)&#123;</span><br><span class="line">            sb.append(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    int compare(String a,String b)&#123;</span><br><span class="line">        int l1 &#x3D; a.length();</span><br><span class="line">        int l2 &#x3D; b.length();</span><br><span class="line">        int l &#x3D; l1+l2;</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        for(;i&lt;l;i++)&#123;</span><br><span class="line">            char ac &#x3D; a.charAt(i%l1);</span><br><span class="line">            char bc &#x3D; b.charAt(i%l2);</span><br><span class="line">            if(ac&#x3D;&#x3D;bc)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            return ac-bc;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">        &#x2F;&#x2F; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b+&quot;,cp:&quot;+cp);</span><br><span class="line">        &#x2F;&#x2F; return cp;</span><br><span class="line">    &#125;</span><br><span class="line">    void quickSort(String[] nums,int start,int end)&#123;</span><br><span class="line">        if(start&gt;&#x3D;end)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int index &#x3D; getIndex(nums,start,end);</span><br><span class="line">        quickSort(nums,start,index-1);</span><br><span class="line">        quickSort(nums,index+1,end);</span><br><span class="line">    &#125;</span><br><span class="line">    int getIndex(String[]nums,int low,int high)&#123;</span><br><span class="line">        String tmp &#x3D; nums[low];</span><br><span class="line">        while(low&lt;high)&#123;</span><br><span class="line">            while(low&lt;high&amp;&amp;compare(nums[high],tmp)&lt;&#x3D;0)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[low] &#x3D; nums[high];</span><br><span class="line">            while(low&lt;high&amp;&amp;compare(nums[low],tmp)&gt;&#x3D;0)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[high] &#x3D; nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] &#x3D; tmp;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>mine<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public String largestNumber(int[] nums) &#123;</span><br><span class="line">    String[] ans &#x3D; new String[nums.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; i++) ans[i] &#x3D; String.valueOf(nums[i]);</span><br><span class="line">    Arrays.sort(ans, new NumComparator());</span><br><span class="line">    StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">    if (ans[0].charAt(0) &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">        return &quot;0&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    for (String num : ans) &#123;</span><br><span class="line">        sb.append(num);</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class NumComparator implements Comparator&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String o1, String o2) &#123;</span><br><span class="line">        int l1 &#x3D; o1.length();</span><br><span class="line">        int l2 &#x3D; o2.length();</span><br><span class="line">        int l &#x3D; l1 + l2;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        for (; i &lt; l; i++) &#123;</span><br><span class="line">            char ac &#x3D; o1.charAt(i % l1);</span><br><span class="line">            char bc &#x3D; o2.charAt(i % l2);</span><br><span class="line">            if (ac &#x3D;&#x3D; bc) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            return  bc - ac;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>lambda<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String largestNumber(int[] nums) &#123;</span><br><span class="line">    String result &#x3D; IntStream.of(nums).mapToObj(String::valueOf).sorted(((o1, o2) -&gt; (o2 + o1).compareTo(o1 + o2))).collect(Collectors.joining());</span><br><span class="line">    return result.startsWith(&quot;0&quot;) ? &quot;0&quot; : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>面试题57 - II. 和为s的连续正数序列-滑动窗口</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lc&amp;nc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaBooks</title>
      <link href="/2020/02/29/JavaBooks/"/>
      <url>/2020/02/29/JavaBooks/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 书籍分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的语法收录</title>
      <link href="/2020/02/29/Hexo%E7%9A%84%E8%AF%AD%E6%B3%95%E6%94%B6%E5%BD%95/"/>
      <url>/2020/02/29/Hexo%E7%9A%84%E8%AF%AD%E6%B3%95%E6%94%B6%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo添加Gitment评论系统&amp;相关问题解决</title>
      <link href="/2020/02/29/Hexo%E6%B7%BB%E5%8A%A0Gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/02/29/Hexo%E6%B7%BB%E5%8A%A0Gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">注册OAuth Application</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/1319879-7cda76c0786cdf16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>注意:<br>1.callback URL需要填自己的博客地址 eg:<a href="https://d0ma4t2.github.io/" target="_blank" rel="noopener">https://d0ma4t2.github.io/</a><br>2.然后你会得到一个Client ID 和一个 Client secret，这个将被用于之后的用户登录</p></blockquote><h3 id="在yelee主题中引入Gitment"><a href="#在yelee主题中引入Gitment" class="headerlink" title="在yelee主题中引入Gitment"></a>在yelee主题中引入Gitment</h3><p>在themes/yelee/layout/_partial/post文件夹下创建git.ejs文件，并写入下边代码：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;git&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;billts.site&#x2F;extra_css&#x2F;gitment.css&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;billts.site&#x2F;js&#x2F;gitment.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var gitment &#x3D; new Gitment(&#123;</span><br><span class="line">  id: &quot;&lt;%&#x3D; page.title %&gt;&quot;,</span><br><span class="line">  owner: &quot;stven0king&quot;,&#x2F;&#x2F;github用户名</span><br><span class="line">  repo: &quot;stven0king.github.io&quot;,&#x2F;&#x2F;用户存储评论的github项目名称</span><br><span class="line">  oauth: &#123;</span><br><span class="line">    id: &quot;&lt;%&#x3D; page.title %&gt;&quot;,</span><br><span class="line">    client_id: &quot;xxxxxxxxxxxxxxxxxxxxxxxx&quot;,&#x2F;&#x2F;注册OAuth Application时生产的ClinetID</span><br><span class="line">    client_secret:&quot;xxxxxxxxxxxxxxxxxxxxx&quot;,&#x2F;&#x2F;注册OAuth Application时生成的Client Secret</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">gitment.render(&#39;git&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!-- Gitment代码结束 --&gt;</span><br></pre></td></tr></table></figure><p>接着在themes/yelee/layout/_partial/article.ejs文件中找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt;</span><br><span class="line">    &lt;% if (theme.duoshuo.on) &#123; %&gt;</span><br><span class="line">      &lt;%- partial(&#39;comments&#x2F;duoshuo&#39;, &#123;</span><br><span class="line">          key: post.path,</span><br><span class="line">          title: post.title,</span><br><span class="line">          url: config.url+url_for(post.path),</span><br><span class="line">          &#125;) %&gt;</span><br><span class="line">    &lt;% &#125; else if (theme.youyan.on) &#123; %&gt;</span><br><span class="line">        &lt;%- partial(&#39;comments&#x2F;youyan&#39;) %&gt;</span><br><span class="line">    &lt;% &#125; else if (theme.disqus.on) &#123; %&gt;</span><br><span class="line">        &lt;%- partial(&#39;comments&#x2F;disqus&#39;, &#123;</span><br><span class="line">            shortname: theme.disqus.shortname</span><br><span class="line">          &#125;) %&gt;</span><br><span class="line">    &lt;% &#125; else if (config.disqus_shortname) &#123; %&gt;</span><br><span class="line">        &lt;%- partial(&#39;comments&#x2F;disqus&#39;, &#123;</span><br><span class="line">            shortname: config.disqus_shortname</span><br><span class="line">          &#125;) %&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>在这个节点下添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!index)&#123; %&gt;</span><br><span class="line">  &lt;% if (post.comments)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;post&#x2F;git&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; else &#123; %&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;git&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>以上所有操作完成后，hexo clean、hexo g -d，然后文章底部就可以展现评论视图了</p><blockquote><p>FAQ<br>1.最开始我们看到的是：Error:Comments Not Initialized，登录你的账号即可<br>2.点击初始化评论<br>3.配置好后，有时候出现object ProgressEvent，可能是网络问题关掉网页重新打开即可<br>4.关于hexo博客自定义域名后gitment评论系统登陆出现redirect error返回主页的解决办法<br><a href="https://www.cnblogs.com/zmj97/p/10421872.html" target="_blank" rel="noopener">https://www.cnblogs.com/zmj97/p/10421872.html</a></p></blockquote><blockquote><p>本文参考：<br><a href="https://www.dazhuanlan.com/2020/01/20/5e2518040b423/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2020/01/20/5e2518040b423/</a><br><a href="https://blog.csdn.net/xiaosongshine/article/details/100614850?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/xiaosongshine/article/details/100614850?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a><br><a href="https://blog.csdn.net/YEN_CSDN/article/details/80142392?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/YEN_CSDN/article/details/80142392?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Gitment </tag>
            
            <tag> FAQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java加强编译运行</title>
      <link href="/2020/02/29/Java%E5%8A%A0%E5%BC%BA%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/"/>
      <url>/2020/02/29/Java%E5%8A%A0%E5%BC%BA%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="grammer-skills"><a href="#grammer-skills" class="headerlink" title="grammer skills"></a>grammer skills</h3><ul><li>变长二维数组转定长<blockquote><p>int[][] res = new ArrayList&lt;&gt;().toArray(new int[res.size()][]);</p></blockquote><a id="more"></a><h3 id="compile-amp-runtime"><a href="#compile-amp-runtime" class="headerlink" title="compile&amp;runtime"></a>compile&amp;runtime</h3></li><li>不要用有参构造函数</li><li>使用移位操作代替乘除法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a&#x2F;4 &#x3D;&#x3D; a &gt;&gt; 2</span><br><span class="line">a&#x2F;8 &#x3D;&#x3D; a &gt;&gt; 3</span><br><span class="line">a×4 &#x3D;&#x3D; a &lt;&lt; 2</span><br><span class="line">a×8 &#x3D;&#x3D; a &lt;&lt; 3</span><br></pre></td></tr></table></figure></li><li>引用类型转换为字符串最好使用toString()，String.valueof()其次，不要使用new String()</li><li>类上申明final</li><li>for使用如下方式 </li><li>复制数组使用System.arraycopy()</li><li>对象应该多重用</li><li>list, map, set, StringBuilder应设定初始值</li><li>顺序插入和随机访问使用arraylist，删除和随机插入使用linklist，无序使用set</li><li>对象比较使用Objects.equals</li><li>使用栈和队列时，使用linklist(插入，删除)或arraydeque(随机访问)，接口为deque</li><li>Collections.reverseOrder()(比较器)可以反转有序集合(list，queue等)</li><li>遍历map的几种方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果只是获取key，或者value，推荐使用keySet或者values方式</span><br><span class="line">&#x2F;&#x2F; KeySet 获取key </span><br><span class="line">public void testKeySet() &#123; </span><br><span class="line">    for (Integer key : map.keySet()) &#123; </span><br><span class="line">        System.out.println(key); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; &#x2F;&#x2F; values 获取value </span><br><span class="line">public void testValues() &#123; </span><br><span class="line">    for (Integer value : map.values()) &#123; </span><br><span class="line">        System.out.println(value); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果同时需要key和value推荐使用entrySet</span><br><span class="line">public void testEntry() &#123; </span><br><span class="line">    for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; </span><br><span class="line">        System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">public void testLambda() &#123; </span><br><span class="line">    map.forEach((key, value) -&gt; &#123; System.out.println(key + &quot;:&quot; + value); &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果需要在遍历过程中删除元素推荐使用Iterator</span><br><span class="line">public void testIterator() &#123; </span><br><span class="line">    Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it &#x3D; map.entrySet().iterator();  </span><br><span class="line">    while (it.hasNext()) &#123; </span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; entry &#x3D; it.next();   </span><br><span class="line">        System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue());   </span><br><span class="line">        &#x2F;&#x2F;it.remove(); 删除元素 </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中</p></blockquote></li><li>加速读取数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static class FastIO &#123;</span><br><span class="line">    BufferedReader reader;</span><br><span class="line">    StringTokenizer tokenizer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void init(InputStream inputStream) &#123;</span><br><span class="line">        reader &#x3D; new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">        tokenizer &#x3D; new StringTokenizer(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;读入一个字符串</span><br><span class="line">    String next() &#123;</span><br><span class="line">        while (!tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                tokenizer &#x3D; new StringTokenizer(reader.readLine());</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tokenizer.nextToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;读入一整行</span><br><span class="line">    String nextLine() &#123;</span><br><span class="line">        while (!tokenizer.hasMoreElements()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                tokenizer &#x3D; new StringTokenizer(reader.readLine());</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tokenizer.nextToken(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;读入int类型数据</span><br><span class="line">    int nextInt() &#123;</span><br><span class="line">        return Integer.parseInt(next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;读入double类型数据</span><br><span class="line">    double nextDouble() &#123;</span><br><span class="line">        return Double.parseDouble(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Character.getNumericValue(char ch)<br>获取Unicode对应int，即char-&gt;int</li><li>HashSet的add方法可以判断是否重复放元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0,length &#x3D; list.length; )</span><br></pre></td></tr></table></figure></li><li>获取整数位数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num &#x3D; num &gt; 0 ? num : -num;       </span><br><span class="line">if (num&#x3D;&#x3D;0) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">return (int) Math.log10(num)+1;</span><br></pre></td></tr></table></figure><h3 id="reduce-mem"><a href="#reduce-mem" class="headerlink" title="reduce mem"></a>reduce mem</h3></li><li>批量创建对象是使用clone方法</li><li>尽量使用局部变量</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java_enhance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> lc&amp;nc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
